#define	_CRT_SECURE_NO_WARNINGS

#include "Comments.h"
#include "File.h"
#include "Functions.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

static const char*	gsc_szFileExtension	= ".cmt";

Comments::Comments(const std::string& _strSystem)	:
	m_strSystem(_strSystem),
	m_csegStart(0),
	m_csegEnd(0)
{
}

Comments::~Comments()
{
	close();
}

Comments::Ptr Comments::create(const std::string& _strSystem, const std::string& _strFilename, const std::string& _strBinaryFilename)
{
	INSTANCE(pComments, Comments(_strSystem))

	if (false == pComments->initialize(_strFilename, _strBinaryFilename))
	{
		pComments.reset();
	}

	return	pComments;
}

bool Comments::initialize(const std::string& _strFilename, const std::string& _strBinaryFilename)
{
	if (false == loadBinary(_strBinaryFilename))
	{
		return	false;
	}

	if (false == loadSymbols(_strFilename))
	{
		return	false;
	}

	return	true;
}

void Comments::close()
{
}

bool Comments::save(const std::string& _strDirectory, const std::string& _strCPUTag)
{
	if (false == File::directoryExists(_strDirectory))
	{
		if (false == File::createDirectory(_strDirectory))
		{
			printf("Unable to create output directory\n");

			return	false;
		}
	}

	std::string	strFilename;

	strFilename	= _strDirectory;
	
	File::addDirectorySeparator(strFilename);
	
	strFilename	+= m_strSystem;
	strFilename	+= gsc_szFileExtension;

	File::Ptr	pFile	= File::create();

	if (nullptr == pFile)
	{
		printf("Unable to create file interface.\n");

		return	false;
	}

	if (false == pFile->create(strFilename))
	{
		printf("Unable to update source file.\n");

		return	false;
	}

	pFile->writeLine("<?xml version=\"1.0\"?>");
	pFile->writeLine("<!-- This file is autogenerated; comments and unknown tags will be stripped -->");
	pFile->writeLine("<mamecommentfile version=\"1\">");

	std::string	strString;

	strString	= "\t<system name=\"";
	strString	+= m_strSystem;
	strString	+= "\">";

	pFile->writeLine(strString);

	strString	= "\t\t<cpu tag=\"";
	strString	+= _strCPUTag;
	strString	+= "\">";

	pFile->writeLine(strString);

	int	t_c	= (int)m_comments.size();

	for (int iLoop = 0; iLoop < t_c; ++iLoop)
	{
		const Comment&	comment	= m_comments[iLoop];

		char	szCRC[9];

		sprintf(szCRC, "%08X", comment.crc);

		strString	= "\t\t\t<comment address=\"";
		strString	+= std::to_string(comment.address);
		strString	+= "\" color=\"16711680\" crc=\"";
		strString	+= szCRC;
		strString	+= "\">";
	
		pFile->writeLine(strString);

		strString	= "\t\t\t\t";
		strString	+= comment.strLine;
	
		pFile->writeLine(strString);

		pFile->writeLine("\t\t\t</comment>");
	}

	pFile->writeLine("\t\t</cpu>");
	pFile->writeLine("\t</system>");
	pFile->writeLine("</mamecommentfile>");

	pFile->close();

	return	true;
}

bool Comments::loadBinary(const std::string& _strFilename)
{
	File::Ptr	pFile	= File::create();

	if (false == pFile->open(_strFilename, true))
	{
		printf("Unable to open file %s.\n", _strFilename.c_str());

		return	false;
	}

	int	iLength	= pFile->getLength();

	SHAREDBUFFER(m_pBinaryBuffer, uint8_t, iLength);

	if (false == pFile->readBuffer(m_pBinaryBuffer.get(), iLength))
	{
		printf("Unable to load file %s\n", _strFilename.c_str());

		return	false;
	}

	pFile->close();

	return	true;
}

bool Comments::loadSymbols(const std::string& _strFilename)
{
	m_symbols.clear();
	m_paths.clear();
	m_files.clear();
	m_comments.clear();

	File::Ptr	pFile	= File::create();

	if (false == pFile->open(_strFilename, true))
	{
		printf("Unable to open file %s.\n", _strFilename.c_str());

		return	false;
	}

	std::vector<std::string>	lines;
	std::string					strRead;

	while (true == pFile->readLine(strRead))
	{
		if (false == strRead.empty() && strRead[0] != '=')
		{
			removeMarker(strRead);

			if (false == strRead.empty())
			{
				lines.push_back(strRead);
			}
		}
	}

	pFile->close();

	int	t_c	= (int)lines.size();

	if (0 == t_c)
	{
		printf("Symbol file does not contain any lines\n");

		return	false;
	}

	m_csegStart	= UINT32_MAX;
	m_csegEnd	= 0;

	for (int iLoop = 0; iLoop < t_c; ++iLoop)
	{
		if (false == findCSEG(lines[iLoop]))
		{
			return	false;
		}
	}

	for (int iLoop = 0; iLoop < t_c; ++iLoop)
	{
		if (false == parseSymbol(lines[iLoop]))
		{
			return	false;
		}
	}

	std::sort(m_symbols.begin(), m_symbols.end(), [](const Symbol& _first, const Symbol& _second)
	{
#if 1
		if (_first.strFilename == _second.strFilename)
		{
			return	_second.address > _first.address;
		}
		return	_second.strFilename > _first.strFilename;
#else
		return	_second.address > _first.address;
#endif
	});

	if (false == findLists())
	{
		return	false;
	}

	return	true;
}

bool Comments::findCSEG(const std::string& _strLine)
{
	std::vector<std::string>&	strTokens	= Functions::tokenize(_strLine, ' ');

	strTokens.erase(std::remove_if(strTokens.begin(), strTokens.end(), [](const std::string& _string)
	{
		return	_string.empty();
	}), strTokens.end());

	if (2 == (int)strTokens.size())
	{
		if ("CSEG" == strTokens[0])
		{
			std::vector<std::string>&	segments	= Functions::tokenize(strTokens[1], ',');

			int	t_c	= (int)segments.size();

			for (int iLoop = 0; iLoop < t_c; ++iLoop)
			{
				std::vector<std::string>&	addresses	= Functions::tokenize(segments[iLoop], '-');

				if (2 == addresses.size() && true == checkHex(addresses[0]) && true == checkHex(addresses[1]))
				{
					uint32_t	start	= Functions::convertHexStringToUnsigned32(addresses[0]);
					uint32_t	end		= Functions::convertHexStringToUnsigned32(addresses[1]);

					if (start < m_csegStart)
					{
						m_csegStart	= start;
					}

					if (end > m_csegEnd)
					{
						m_csegEnd	= end;
					}
				}
			}
		}
	}

	return	true;
}

bool Comments::parseSymbol(const std::string& _strLine)
{
	std::vector<std::string>&	strTokens	= Functions::tokenize(_strLine, ' ');

	strTokens.erase(std::remove_if(strTokens.begin(), strTokens.end(), [](const std::string& _string)
	{
		return	_string.empty();
	}), strTokens.end());

	if (3 == (int)strTokens.size())
	{
		if (true == checkHex(strTokens[1]))
		{
			Symbol	symbol;

			symbol.strName		= strTokens[0];
			symbol.address		= Functions::convertHexStringToUnsigned32(strTokens[1]);
			symbol.strFilename	= strTokens[2];

			if (symbol.address >= m_csegStart && symbol.address <= m_csegEnd)
			{
				m_symbols.push_back(symbol);

				m_files.insert(symbol.strFilename);
			}
		}
	}

	return	true;
}

bool Comments::findLists()
{
	std::string	strDirectory;

	strDirectory	= ".";

	findDirectories(strDirectory);

	int	iDirectories	= (int)m_paths.size();

	for (PathIterator iterator = m_paths.begin(); iterator != m_paths.end(); ++iterator)
	{
		std::string	strDirectory;
		std::string	strPath;

		strDirectory	= *iterator;

		strPath	= strDirectory;
		strPath	+= "//*.lst";

		std::vector<std::string>	listFiles;

		if (false == File::findFiles(strPath, listFiles))
		{
			continue;
		}
	
		int	iListFiles	= (int)listFiles.size();

		for (int iListFile = 0; iListFile < iListFiles; ++iListFile)
		{
			std::string	strFilename;

			strFilename	= strDirectory;
			strFilename	+= "/";
			strFilename	+= listFiles[iListFile];

			int	iStartAddress	= getFileStartAddress(listFiles[iListFile]);

			if (-1 == iStartAddress || false == parseComments(strFilename, iStartAddress))
			{
				continue;
			}
		}
	}

	return	true;
}

bool Comments::parseComments(const std::string& _strFilename, int _iStartAddress)
{
	File::Ptr	pFile	= File::create();

	if (false == pFile->open(_strFilename, true))
	{
		printf("Unable to open file %s.\n", _strFilename.c_str());

		return	false;
	}

	std::vector<std::string>	lines;
	std::string					strRead;

	while (true == pFile->readLine(strRead))
	{
		if ('=' == strRead[0])
		{
			continue;
		}
		
		removeMarker(strRead);

		if (false == strRead.empty())
		{
			lines.push_back(strRead);
		}
	}

	pFile->close();

	int	t_c	= (int)lines.size();

	if (0 == t_c)
	{
		printf("List file does not contain any lines\n");

		return	false;
	}

	int	iCurrentAddress;

	for (int iLoop = 0; iLoop < t_c; ++iLoop)
	{
		Comment	comment;

		if (true == parseComment(lines[iLoop], comment, _iStartAddress, iCurrentAddress))
		{
			m_comments.push_back(comment);
		}
	}

	std::sort(m_comments.begin(), m_comments.end(), [](const Comment& _first, const Comment& _second)
	{
		if (_first.address < _second.address)
		{
			return	true;
		}

		return	false;
	});

	return	true;
}

bool Comments::parseComment(const std::string& _strLine, Comment& _comment, int _iStartAddress, int& _iCurrentAddress)
{
	std::vector<std::string>&	strTokens	= Functions::tokenize(_strLine, ' ');

	strTokens.erase(std::remove_if(strTokens.begin(), strTokens.end(), [](const std::string& _string)
	{
		return	_string.empty();
	}), strTokens.end());

	int	iTokens	= (int)strTokens.size();

	if (iTokens >= 3)
	{
		size_t	iPosition	= strTokens[0].find("'");

		if (iPosition != std::string::npos)
		{
			strTokens[0].erase(iPosition, 1);

			// Check to ensure offset and instruction bytes are valid
			if (false == checkHex(strTokens[0]) || false == checkHex(strTokens[1]))
			{
				return	false;
			}

			int	iOffset	= (int)Functions::convertHexStringToUnsigned32(strTokens[0]);

			_iCurrentAddress	= _iStartAddress + iOffset;

			_comment.address	= _iCurrentAddress;

			_comment.crc	= calculateCRC(_iCurrentAddress - m_csegStart, strTokens[1].length() / 2);

			_iCurrentAddress	+= iOffset;

			for (int iLoop = 2; iLoop < iTokens; ++iLoop)
			{
				std::replace(strTokens[iLoop].begin(), strTokens[iLoop].end(), '\t', ' '); 

				_comment.strLine	+= strTokens[iLoop];

				if (iLoop < iTokens - 1)
				{
					_comment.strLine	+= " ";
				}
			}

			return	true;
		}
	}

	return	false;
}

void Comments::removeMarker(std::string& _strString)
{
	if (0xEF == (uint8_t)_strString[0])
	{
		_strString.erase(0, 1);
	}

	if (0xBB == (uint8_t)_strString[0])
	{
		_strString.erase(0, 1);
	}

	if (0xBF == (uint8_t)_strString[0])
	{
		_strString.erase(0, 1);
	}
}

int Comments::getFileStartAddress(const std::string& _strFilename)
{
	size_t	iObjOffset	= _strFilename.find_last_of(".lst");

	if (std::string::npos != iObjOffset)
	{
		std::string	strListName;

		strListName	= _strFilename.substr(0, iObjOffset - 3);
		strListName	+= ".obj";

		int	t_c	= (int)m_symbols.size();

		for (int iLoop = 0; iLoop < t_c; ++iLoop)
		{
			const Symbol&	symbol	= m_symbols[iLoop];

			if (strListName == symbol.strFilename)
			{
				return	symbol.address;
			}
		}
	}

	return	-1;
}

bool Comments::checkHex(const std::string& _strInstruction)
{
	int	t_c	= (int)_strInstruction.length();

	for (int iLoop = 0; iLoop < t_c; ++iLoop)
	{
		if (false == isxdigit(_strInstruction[iLoop]))
		{
			return	false;
		}
	}

	return	true;
}

uint32_t Comments::calculateCRC(int _iOffset, int _iLength)
{
	uint8_t*	pBuffer	= m_pBinaryBuffer.get() + _iOffset;

	uint32_t	crc	= stbiw__crc32(pBuffer, _iLength);

	return	crc;
}

bool Comments::findDirectories(const std::string& _strDirectory)
{
	m_paths.insert(_strDirectory);

	std::vector<std::string>	directories;

	File::findDirectories(_strDirectory, directories);
	
	int	t_c	= (int)directories.size();

	for (int iLoop = 0; iLoop < t_c; ++iLoop)
	{
		std::string	strDirectory;

		strDirectory	= _strDirectory;
		strDirectory	+= "/";
		strDirectory	+= directories[iLoop];

		findDirectories(strDirectory);
	}

	return	true;
}
